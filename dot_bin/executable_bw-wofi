#!/usr/bin/env bash
# bw-wofi — Bitwarden credential picker for Fuzzel (Wayland)
#
# Dependencies: bw, fuzzel, wtype, wl-copy, jq, secret-tool, notify-send
#
# Session flow:
#   1. Try to retrieve a stored session key from the system keyring
#   2. If not found or vault is locked, prompt for the master password via fuzzel
#   3. Unlock vault, store new session key in keyring
#   4. List all vault items → pick one via fuzzel
#   5. Pick an action → execute

set -euo pipefail

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------
SECRET_SERVICE="bitwarden-cli"
SECRET_ATTR="session"
NOTIFY_APP="Bitwarden"

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
die() {
    notify-send -a "$NOTIFY_APP" -u critical "Error" "$*"
    echo "ERROR: $*" >&2
    exit 1
}

notify() {
    notify-send -a "$NOTIFY_APP" "$@"
}

fuzzel_menu() {
    local prompt="$1"
    shift
    fuzzel --dmenu --prompt="$prompt" "$@"
}

fuzzel_password() {
    local prompt="$1"
    shift
    fuzzel --dmenu --password --prompt="$prompt" "$@"
}

# ---------------------------------------------------------------------------
# Session Management
# ---------------------------------------------------------------------------
get_session_from_keyring() {
    secret-tool lookup service "$SECRET_SERVICE" attribute "$SECRET_ATTR" 2>/dev/null || true
}

store_session_in_keyring() {
    local session_key="$1"
    printf '%s' "$session_key" | \
        secret-tool store --label="Bitwarden CLI Session" \
            service "$SECRET_SERVICE" attribute "$SECRET_ATTR" 2>/dev/null || true
}

clear_session_from_keyring() {
    secret-tool clear service "$SECRET_SERVICE" attribute "$SECRET_ATTR" 2>/dev/null || true
}

is_vault_unlocked() {
    local session_key="$1"
    local status
    status=$(bw status --session "$session_key" 2>/dev/null | jq -r '.status' 2>/dev/null || echo "locked")
    [[ "$status" == "unlocked" ]]
}

unlock_vault() {
    local password
    password=$(fuzzel_password "Vault password: ") || die "No password provided."
    [[ -z "$password" ]] && die "No password provided."

    local session_key
    session_key=$(BW_PASSWORD="$password" bw unlock --raw --passwordenv BW_PASSWORD 2>/dev/null) || true

    # Fallback: pass password directly
    if [[ -z "$session_key" ]]; then
        session_key=$(bw unlock "$password" --raw 2>/dev/null) || true
    fi

    [[ -z "$session_key" ]] && die "Failed to unlock vault. Wrong password?"

    store_session_in_keyring "$session_key"
    echo "$session_key"
}

acquire_session() {
    local session_key
    session_key=$(get_session_from_keyring)

    if [[ -n "$session_key" ]] && is_vault_unlocked "$session_key"; then
        echo "$session_key"
        return
    fi

    # Keyring had nothing or session is stale — wipe and re-unlock
    clear_session_from_keyring
    unlock_vault
}

# ---------------------------------------------------------------------------
# Item helpers
# ---------------------------------------------------------------------------

# Map numeric type to a readable label
item_type_label() {
    case "$1" in
        1) echo "Login" ;;
        2) echo "Note" ;;
        3) echo "Card" ;;
        4) echo "Identity" ;;
        *) echo "Item" ;;
    esac
}

# Build the display line shown in the first fuzzel menu
# Format: "[Type] Name — username  [OTP]"
build_item_line() {
    local name="$1"
    local type_label="$2"
    local username="$3"
    local has_totp="$4"

    local line="[${type_label}] ${name}"
    [[ -n "$username" ]] && line+=" — ${username}"
    [[ "$has_totp" == "true" ]] && line+="  [OTP]"
    echo "$line"
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
    # --- Acquire a valid session ---
    BW_SESSION=$(acquire_session)
    export BW_SESSION
    [[ -z "$BW_SESSION" ]] && die "Could not obtain a valid Bitwarden session."

    # --- Fetch all items ---
    local raw_items
    raw_items=$(bw list items --session "$BW_SESSION" 2>/dev/null) || \
        die "Failed to list vault items. Try syncing: bw sync"

    [[ -z "$raw_items" || "$raw_items" == "[]" ]] && die "Vault is empty."

    # Build associative array: display_line → item JSON (indexed by line number)
    local -a display_lines=()
    local -a item_ids=()
    local -a item_names=()
    local -a item_usernames=()
    local -a item_passwords=()
    local -a item_totps=()
    local -a item_types=()

    local count
    count=$(echo "$raw_items" | jq 'length')

    for (( i=0; i<count; i++ )); do
        local item
        item=$(echo "$raw_items" | jq ".[$i]")

        local id name type username password has_totp type_label
        id=$(echo "$item" | jq -r '.id')
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        type_label=$(item_type_label "$type")
        username=$(echo "$item" | jq -r '.login.username // ""')
        password=$(echo "$item" | jq -r '.login.password // ""')
        has_totp=$(echo "$item" | jq -r 'if .login.totp != null and .login.totp != "" then "true" else "false" end')

        local line
        line=$(build_item_line "$name" "$type_label" "$username" "$has_totp")

        display_lines+=("$line")
        item_ids+=("$id")
        item_names+=("$name")
        item_usernames+=("$username")
        item_passwords+=("$password")
        item_totps+=("$has_totp")
        item_types+=("$type")
    done

    # --- Present item picker ---
    local selected_line
    selected_line=$(printf '%s\n' "${display_lines[@]}" | fuzzel_menu "Bitwarden: ") || exit 0
    [[ -z "$selected_line" ]] && exit 0

    # Resolve selected index
    local selected_idx=-1
    for (( i=0; i<${#display_lines[@]}; i++ )); do
        if [[ "${display_lines[$i]}" == "$selected_line" ]]; then
            selected_idx=$i
            break
        fi
    done

    [[ $selected_idx -lt 0 ]] && die "Could not match selected item."

    local sel_id="${item_ids[$selected_idx]}"
    local sel_name="${item_names[$selected_idx]}"
    local sel_username="${item_usernames[$selected_idx]}"
    local sel_password="${item_passwords[$selected_idx]}"
    local sel_has_totp="${item_totps[$selected_idx]}"
    local sel_type="${item_types[$selected_idx]}"

    # --- Build action menu ---
    local -a actions=()

    # Autofill only makes sense for login items with at least a password
    if [[ "$sel_type" == "1" && -n "$sel_username" && -n "$sel_password" ]]; then
        actions+=("Autofill (username + password)")
    fi
    [[ -n "$sel_username" ]] && actions+=("Copy username")
    [[ -n "$sel_password" ]] && actions+=("Copy password")
    [[ "$sel_has_totp" == "true" ]] && actions+=("Copy OTP")

    [[ ${#actions[@]} -eq 0 ]] && die "No actions available for '${sel_name}'."

    local chosen_action
    chosen_action=$(printf '%s\n' "${actions[@]}" | fuzzel_menu "${sel_name}: ") || exit 0
    [[ -z "$chosen_action" ]] && exit 0

    # --- Execute action ---
    case "$chosen_action" in
        "Autofill (username + password)")
            # Small sleep so fuzzel has time to close and the previous window regains focus
            sleep 0.3
            wtype -s 30 "$sel_username" -k Tab -s 30 "$sel_password"
            ;;
        "Copy username")
            printf '%s' "$sel_username" | wl-copy
            notify "Copied" "Username copied to clipboard."
            ;;
        "Copy password")
            printf '%s' "$sel_password" | wl-copy
            notify "Copied" "Password copied to clipboard."
            ;;
        "Copy OTP")
            local otp
            otp=$(bw get totp "$sel_id" --session "$BW_SESSION" 2>/dev/null) || \
                die "Failed to get OTP for '${sel_name}'."
            [[ -z "$otp" ]] && die "No OTP available for '${sel_name}'."
            printf '%s' "$otp" | wl-copy
            notify "Copied" "OTP copied to clipboard."
            ;;
        *)
            die "Unknown action: $chosen_action"
            ;;
    esac
}

main "$@"
